{
  "uuid": "4043abfd-5c0f-4364-a689-1d73af1b4f50",
  "name": "Relation",
  "description": "erzeugt eine Relationenklasse mit den möglichen Ausprägungen \"1-1\", \"1-*\", \"*-1\" und \"*-*\"",
  "extraSearchTerms": [
    "manytomany",
    "realtion"
  ],
  "tags": [
    "ged",
    "realtion"
  ],
  "code": "package ${enclosing_package};\r\n\r\n/* \r\n * Projekt JoKer - Java basiertes, objektorientiertes Kernprojekt \r\n * (c)opyright ${year} Bausparkasse Mainz AG \r\n */\r\n\r\nimport java.text.MessageFormat;\r\nimport de.bkm.bes.basis.annotation.Persistence;\r\nimport de.bkm.bes.basis.annotation.Persistence;\r\nimport de.bkm.bes.basis.annotation.Indexing;\r\nimport de.bkm.bes.basis.annotation.IndexingType;\r\nimport org.eclipse.persistence.indirection.ValueHolder;\r\nimport org.eclipse.persistence.indirection.ValueHolderInterface;\r\nimport de.bkm.bes.basis.history.relation.BesRelationRuntimeException;\r\nimport de.bkm.bes.basis.history.relation.BoIRelation;\r\nimport de.jdpe.bof.bo.eh.BoException;\r\nimport de.jdpe.bof.bo.pm.BoId;\r\nimport de.jdpe.bof.bo.pm.BoInterface;\r\nimport de.jdpe.bof.bo.pm.TaskServerControllerInterface;\r\nimport de.jdpe.bof.bo.tm.BotTimestamp;\r\nimport java.sql.Timestamp;\r\n\r\n/**\r\n * Relationenklasse ${clientMultiplicity:var(java.jang.String)} - ${supplierMultiplicity:var(java.jang.String)}\r\n * zwischen den Klassen ${clientClassName:var(java.lang.String)}\r\n *   (RoleName ${ClientRoleName:var(java.lang.String)} / ${clientRoleName:var(java.lang.String)})\r\n * und ${supplierClassName:var(java.lang.String)}\r\n *   (RoleName ${SupplierRoleName:var(java.lang.String)} / ${supplierRoleName:var(java.lang.String)})\r\n * \u003cbr\u003e\r\n * @author ${user}\r\n * @version $$Id$$\r\n */\r\n@Persistence(true)\r\npublic class ${primary_type_name}  implements BoInterface, BoIRelation\r\n{\r\n\r\n  /**\r\n   * Setzt das Attribut istLogischGeloescht\r\n   *\r\n   * @param istLogischGeloescht boolean\r\n   * @see #istLogischGeloescht\r\n   */\r\n  public void setIstLogischGeloescht(final boolean istLogischGeloescht)\r\n  {\r\n  \tthis.istLogischGeloescht \u003d istLogischGeloescht;\r\n  }\r\n\r\n  /**\r\n   * Ermöglicht das setzen des Attributs istLogischGeloescht durch übergabe als Integer-Object.\r\n   * Diese Funktionalität wird von der Migration benötigt.\r\n   *\r\n   * @param value istLogischGeloescht als Integer-Object\r\n   * @see #istLogischGeloescht\r\n   */\r\n  public void setIstLogischGeloescht(final Boolean value)\r\n  {\r\n  \ttry\r\n  \t{\r\n  \t\tsetIstLogischGeloescht(value.booleanValue());\r\n  \t}\r\n  \tcatch (NullPointerException ex)\r\n  \t{\r\n  \t\tthrow new BoException(\r\n  \t\t\t\"Null is not valid for Attribute boolean \" +\r\n  \t\t\tthis.getRoleName() +\r\n  \t\t\t\".istLogischGeloescht\");\r\n  \t}\r\n  }\r\n\r\n  /**\r\n   * Ermöglicht das setzen des Attributs istLogischGeloescht durch übergabe als Object.\r\n   * Diese Funktionalität wird von der Migration benötigt.\r\n   *\r\n   * @param obj istLogischGeloescht als Object\r\n   * @see #istLogischGeloescht\r\n   */\r\n  public void setIstLogischGeloeschtAsObject(final Object obj)\r\n  {\r\n  \ttry\r\n  \t{\r\n  \t\tsetIstLogischGeloescht(((Boolean)obj).booleanValue());\r\n  \t}\r\n  \tcatch (NullPointerException ex)\r\n  \t{\r\n  \t\tthrow new BoException(\r\n  \t\t\t\"Null is not valid for Attribute boolean \" +\r\n  \t\t\tthis.getRoleName() +\r\n  \t\t\t\".istLogischGeloescht\");\r\n  \t}\r\n  }\r\n\r\n  /**\r\n   * Gibt das Attribut istLogischGeloescht zurück.\r\n   *\r\n   * @return boolean istLogischGeloescht\r\n   */\r\n  public boolean getIstLogischGeloescht()\r\n  {\r\n    return this.istLogischGeloescht;\r\n  }\r\n\r\n  /**\r\n   * Attribut für persitentes TOPLink-Mapping um\r\n   * festzuhalten der BotTimestamp gueltigAb null ist.\r\n   */\r\n  @Indexing(IndexingType.NO_INDEX)\r\n  private boolean gueltigAbIsN \u003d true;\r\n  \r\n  /**\r\n   * Attribut für persitentes TOPLink-Mapping um die\r\n   * Präzision des BotTimestamp gueltigAb zu speichern.\r\n   */\r\n  @Indexing(IndexingType.NO_INDEX)\r\n  private int gueltigAbPre \u003d -1;\r\n  \r\n  /**\r\n   * Attribut für persitentes TOPLink-Mapping um den\r\n   * Datumswert des BotTimestamp gueltigAb zu speichern.\r\n   */\r\n  @Indexing(IndexingType.NO_INDEX)\r\n  private Timestamp gueltigAbDat \u003d null;\r\n  \r\n  /**\r\n   * Gibt den BotTimestamp gueltigAb zurück.\r\n   *\r\n   * @return BotTimestamp gueltigAb\r\n   */\r\n  public final BotTimestamp getGueltigAb()\r\n  {\r\n    if (!this.gueltigAbIsN)\r\n    {\r\n      if (this.gueltigAb \u003d\u003d null)\r\n      {\r\n        this.gueltigAb \u003d\r\n          BotTimestamp.initBotTimestampFromTOPLink(\r\n            this.gueltigAbDat.toString(),\r\n            this.gueltigAbPre);\r\n      }\r\n    }\r\n    return this.gueltigAb;\r\n  }\r\n  /**\r\n   * Setzt den BotTimestamp gueltigAb.\r\n   *\r\n   * @param botTimestamp gueltigAb\r\n   */\r\n  public final void setGueltigAb(final BotTimestamp botTimestamp)\r\n  {\r\n    if (botTimestamp \u003d\u003d null)\r\n    {\r\n      this.gueltigAbIsN \u003d true;\r\n      this.gueltigAb \u003d null;\r\n      this.gueltigAbDat \u003d null;\r\n      this.gueltigAbPre \u003d -1;\r\n    }\r\n    else\r\n    {\r\n      this.gueltigAbIsN \u003d false;\r\n      this.gueltigAb \u003d botTimestamp;\r\n      this.gueltigAbDat \u003d new Timestamp(botTimestamp.getValue().getTimeInMillis());\r\n      this.gueltigAbPre \u003d botTimestamp.getPrecision();\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * BotTimestamp - Zugriffsmethode für das InlineMapping durch TOPLink.\r\n   * @return boolean isn \u003ccode\u003etrue\u003c/code\u003e wenn der BotTimestamp gueltigAb\r\n   *         \u003ccode\u003enull\u003c/code\u003e ist, ansonsten \u003ccode\u003efalse\u003c/code\u003e\r\n   */\r\n  public final boolean getGueltigAbIsN()\r\n  {\r\n    return this.gueltigAbIsN;\r\n  }\r\n  \r\n  /**\r\n   * BotTimestamp - Zugriffsmethode für das InlineMapping durch TOPLink.\r\n   * @return int Präzision des BotTimestamp gueltigAb\r\n   */\r\n  public final int getGueltigAbPre()\r\n  {\r\n    return this.gueltigAbPre;\r\n  }\r\n  \r\n  /**\r\n   * BotTimestamp - Zugriffsmethode für das InlineMapping durch TOPLink.\r\n   * @return String Datumswert des BotTimestamp gueltigAb\r\n   */\r\n  public final Timestamp getGueltigAbDat()\r\n  {\r\n    return this.gueltigAbDat;\r\n  }\r\n  \r\n  /**\r\n   * BotTimestamp - Zugriffsmethode für das InlineMapping durch TOPLink.\r\n   *\r\n   * @param isn \u003ccode\u003etrue\u003c/code\u003e wenn der BotTimestamp gueltigAb\r\n   *        \u003ccode\u003enull\u003c/code\u003e ist, ansonsten \u003ccode\u003efalse\u003c/code\u003e\r\n   */\r\n  public final void setGueltigAbIsN(final boolean isn)\r\n  {\r\n    this.gueltigAbIsN \u003d isn;\r\n    this.gueltigAb \u003d null;\r\n  }\r\n  \r\n  /**\r\n   * BotTimestamp - Zugriffsmethode für das InlineMapping durch TOPLink.\r\n   * @param pre Präzision des BotTimestamp gueltigAb\r\n   */\r\n  public final void setGueltigAbPre(final int pre)\r\n  {\r\n    this.gueltigAbPre \u003d pre;\r\n    this.gueltigAb \u003d null;\r\n  }\r\n  \r\n  /**\r\n   * BotTimestamp - Zugriffsmethode für das InlineMapping durch TOPLink.\r\n   * @param dat Datumswert des BotTimestamp gueltigAb\r\n   */\r\n  public final void setGueltigAbDat(final Timestamp dat)\r\n  {\r\n    this.gueltigAbDat \u003d dat;\r\n    this.gueltigAb \u003d null;\r\n  }\r\n\r\n  /**\r\n   * Attribut für persitentes TOPLink-Mapping um\r\n   * festzuhalten der BotTimestamp gueltigBis null ist.\r\n   * @Indexing(IndexingType.NO_INDEX)\r\n   */\r\n  private boolean gueltigBisIsN \u003d true;\r\n\r\n  /**\r\n   * Attribut für persitentes TOPLink-Mapping um die\r\n   * Präzision des BotTimestamp gueltigBis zu speichern.\r\n   * @Indexing(IndexingType.NO_INDEX)\r\n   */\r\n  private int gueltigBisPre \u003d -1;\r\n  \r\n  /**\r\n   * Attribut für persitentes TOPLink-Mapping um den\r\n   * Datumswert des BotTimestamp gueltigBis zu speichern.\r\n   * @Indexing(IndexingType.NO_INDEX)\r\n   */\r\n  private Timestamp gueltigBisDat \u003d null;\r\n  /**\r\n   * Gibt den BotTimestamps gueltigBis zurück.\r\n   *\r\n   * @return BotTimestamp gueltigBis\r\n   */\r\n  public final BotTimestamp getGueltigBis()\r\n  {\r\n    if (!this.gueltigBisIsN)\r\n    {\r\n      if (this.gueltigBis \u003d\u003d null)\r\n      {\r\n        this.gueltigBis \u003d\r\n          BotTimestamp.initBotTimestampFromTOPLink(\r\n            this.gueltigBisDat.toString(),\r\n            this.gueltigBisPre);\r\n      }\r\n    }\r\n    return this.gueltigBis;\r\n  }\r\n  \r\n  /**\r\n   * Setzt den BotTimestamp gueltigBis.\r\n   *\r\n   * @param botTimestamp gueltigBis\r\n   */\r\n  public final void setGueltigBis(final BotTimestamp botTimestamp)\r\n  {\r\n    if (botTimestamp \u003d\u003d null)\r\n    {\r\n      this.gueltigBisIsN \u003d true;\r\n      this.gueltigBis \u003d null;\r\n      this.gueltigBisDat \u003d null;\r\n      this.gueltigBisPre \u003d -1;\r\n    }\r\n    else\r\n    {\r\n      this.gueltigBisIsN \u003d false;\r\n      this.gueltigBis \u003d botTimestamp;\r\n      this.gueltigBisDat \u003d new Timestamp(botTimestamp.getValue().getTimeInMillis());\r\n      this.gueltigBisPre \u003d botTimestamp.getPrecision();\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * BotTimestamp - Zugriffsmethode für das InlineMapping durch TOPLink.\r\n   * @return isn \u003ccode\u003etrue\u003c/code\u003e wenn der BotTimestamp gueltigBis\r\n   *         \u003ccode\u003enull\u003c/code\u003e ist, ansonsten \u003ccode\u003efalse\u003c/code\u003e\r\n   */\r\n  public final boolean getGueltigBisIsN()\r\n  {\r\n    return this.gueltigBisIsN;\r\n  }\r\n  \r\n  /**\r\n   * BotTimestamp - Zugriffsmethode für das InlineMapping durch TOPLink.\r\n   * @return Präzision des BotTimestamp gueltigBis\r\n   */\r\n  public final int getGueltigBisPre()\r\n  {\r\n    return this.gueltigBisPre;\r\n  }\r\n\r\n  /**\r\n   * BotTimestamp - Zugriffsmethode für das InlineMapping durch TOPLink.\r\n   * @return Datumswert des BotTimestamp gueltigBis\r\n   */\r\n  public final Timestamp getGueltigBisDat()\r\n  {\r\n    return this.gueltigBisDat;\r\n  }\r\n  \r\n  /**\r\n   * BotTimestamp - Zugriffsmethode für das InlineMapping durch TOPLink.\r\n   *\r\n   * @param isn \u003ccode\u003etrue\u003c/code\u003e wenn der BotTimestamp gueltigBis\r\n   *        \u003ccode\u003enull\u003c/code\u003e ist, ansonsten \u003ccode\u003efalse\u003c/code\u003e\r\n   */\r\n  public final void setGueltigBisIsN(final boolean isn)\r\n  {\r\n    this.gueltigBisIsN \u003d isn;\r\n    this.gueltigBis \u003d null;\r\n  }\r\n  \r\n  /**\r\n   * BotTimestamp - Zugriffsmethode für das InlineMapping durch TOPLink.\r\n   * @param pre Präzision des BotTimestamp gueltigBis\r\n   */\r\n  public final void setGueltigBisPre(final int pre)\r\n  {\r\n    this.gueltigBisPre \u003d pre;\r\n    this.gueltigBis \u003d null;\r\n  }\r\n  \r\n  /**\r\n   * BotTimestamp - Zugriffsmethode für das InlineMapping durch TOPLink.\r\n   * @param dat Datumswert des BotTimestamp gueltigBis\r\n   */\r\n  public final void setGueltigBisDat(final Timestamp dat)\r\n  {\r\n    this.gueltigBisDat \u003d dat;\r\n    this.gueltigBis \u003d null;\r\n  }\r\n\r\n  /**\r\n   * Liefert das Objekt, auf das sich die Relation bezieht.\r\n   *\r\n   * @return Objekt vom Typ ${clientClassName},\r\n   *         auf das die Relation verweist.\r\n   */\r\n  public ${clientClassName} get${ClientRoleName}()\r\n  {\r\n    ${clientClassName} obj \u003d (${clientClassName}) this.${clientRoleName}.getValue();\r\n\r\n    if (obj !\u003d null)\r\n    {\r\n      obj.setTaskServerControllerInterface(getTaskServerControllerInterface());\r\n    }\r\n    return obj;\r\n  }\r\n  /**\r\n   * Legt fest auf welches Objekt sich die Relation bezieht.\r\n   *\r\n   * @param obj Das Objekt, vom Typ ${clientClassName},\r\n   *            zu dem eine Relation erzeugt werden soll.\r\n   */\r\n  public void set${ClientRoleName}(final ${clientClassName} obj)\r\n  {\r\n    // TOPLink ONE_TO_MANY: Wenn Attribut auf der Gegenseite navigierbar ist.\r\n    if (obj \u003d\u003d null)\r\n    {\r\n      // Referenz ist null -\u003e Entfernen auf der Gegenseite\r\n      if (get${ClientRoleName}() !\u003d null)\r\n      {\r\n        //\r\n      \t//Beziehung auf der Gegenseite (am ${clientClassName}) zu dieser Relationenklasse (${primary_type_name})\r\n      \t//mit Hilfe der remove...OneWay-Methode entfernen\r\n      \t//\r\n        get${ClientRoleName}().removeRelation${SupplierRoleName}OneWay (this);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      // Referenz ist nicht null...\r\n\r\n      // Ist bereits ein Objekte zugordnet?\r\n      if (get${ClientRoleName}() !\u003d null)\r\n      {\r\n        // Wenn das gleiche Objekt nochmal gesetzt werden soll,...\r\n        if (obj.getBoId().equals(get${ClientRoleName}().getBoId()))\r\n        {\r\n          // ...passiert nichts.\r\n          return;\r\n        }\r\n        else\r\n        {\r\n          //\r\n      \t\t//Beziehung auf der Gegenseite (am ${clientClassName}) zu dieser Relationenklasse (${primary_type_name})\r\n\t      \t//mit Hilfe der remove...OneWay-Methode entfernen\r\n  \t    \t//\r\n          get${ClientRoleName}().removeRelation${SupplierRoleName}OneWay(this);\r\n        }\r\n      }\r\n      //\r\n      //Beziehung auf der Gegenseite (am ${clientClassName}) zu dieser Relationenklasse (${primary_type_name})\r\n      //mit Hilfe der add...OneWay-Methode hinzufügen\r\n      //\r\n      obj.addRelation${SupplierRoleName}OneWay(this);\r\n    }\r\n    this.${clientRoleName}.setValue(obj);\r\n  }\r\n  /**\r\n   * TOPLink ONE_TO_MANY: Wenn Attribut auf der Gegenseite navigierbar ist.\r\n   *\r\n   * @param obj ${clientClassName}-Objekt für das eine Relation\r\n   *            hergestellt werden soll\r\n   */\r\n  public void set${ClientRoleName}OneWay(final ${clientClassName} obj)\r\n  {\r\n    // Falls es schon eine Referezen gibt, muß diese erst entfernt werden.\r\n    if (get${ClientRoleName}() !\u003d null)\r\n    {\r\n      //\r\n      //Beziehung auf der Gegenseite (am ${clientClassName}) zu dieser Relationenklasse (${primary_type_name})\r\n\t    //mit Hilfe der remove...OneWay-Methode entfernen\r\n  \t  //\r\n      get${ClientRoleName}().removeRelation${SupplierRoleName}OneWay(this);\r\n    }\r\n\r\n    this.${clientRoleName}.setValue(obj);\r\n  }\r\n  /**\r\n   * Gibt den ValueHolder, bei einer 1:n Relation, für TOPLink zurück.\r\n   *\r\n   * @return ValueHolder für das lazy-loading von TOPLink\r\n   */\r\n  public ValueHolderInterface get${ClientRoleName}Holder()\r\n  {\r\n    ValueHolderInterface holder \u003d this.${clientRoleName};\r\n\r\n    if (holder.isInstantiated())\r\n    {\r\n      BoInterface bo \u003d (BoInterface) holder.getValue();\r\n      if (bo !\u003d null \u0026\u0026 !bo.getBoId().isValid())\r\n      {\r\n        holder.setValue(null);\r\n      }\r\n    }\r\n    return holder;\r\n  }\r\n  /**\r\n   * Setzt den ValueHolder, bei einer \"1-zu\" Relation, für TOPLink.\r\n   *\r\n   * @param valueHolder ValueHolder für das lazy-loading von TOPLink\r\n   */\r\n  public void set${ClientRoleName}Holder(final ValueHolderInterface valueHolder)\r\n  {\r\n    this.${clientRoleName} \u003d valueHolder;\r\n  }\r\n\r\n  /**\r\n   * Liefert das Objekt, auf das sich die Relation bezieht.\r\n   *\r\n   * @return Objekt vom Typ ${supplierClassName},\r\n   *         auf das die Relation verweist.\r\n   */\r\n  public ${supplierClassName} get${SupplierRoleName}()\r\n  {\r\n    ${supplierClassName} obj \u003d (${supplierClassName}) this.${supplierRoleName}.getValue();\r\n\r\n    if (obj !\u003d null)\r\n    {\r\n      obj.setTaskServerControllerInterface(getTaskServerControllerInterface());\r\n    }\r\n    return obj;\r\n  }\r\n  /**\r\n   * Legt fest auf welches Objekt sich die Relation bezieht.\r\n   *\r\n   * @param obj Das Objekt, vom Typ ${supplierClassName},\r\n   *            zu dem eine Relation erzeugt werden soll.\r\n   */\r\n  public void set${SupplierRoleName}(final ${supplierClassName} obj)\r\n  {\r\n    // TOPLink ONE_TO_MANY: Wenn Attribut auf der Gegenseite navigierbar ist.\r\n    if (obj \u003d\u003d null)\r\n    {\r\n      // Referenz ist null -\u003e Entfernen auf der Gegenseite\r\n      if (get${SupplierRoleName}() !\u003d null)\r\n      {\r\n        //\r\n      \t//Beziehung auf der Gegenseite (am ${supplierClassName}) zu dieser Relationenklasse (${primary_type_name})\r\n\t      //mit Hilfe der remove...OneWay-Methode entfernen\r\n  \t    //\r\n        get${SupplierRoleName}().removeRelation${ClientRoleName}OneWay (this);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      // Referenz ist nicht null...\r\n\r\n      // Ist bereits ein Objekte zugordnet?\r\n      if (get${SupplierRoleName}() !\u003d null)\r\n      {\r\n        // Wenn das gleiche Objekt nochmal gesetzt werden soll,...\r\n        if (obj.getBoId().equals(get${SupplierRoleName}().getBoId()))\r\n        {\r\n          // ...passiert nichts.\r\n          return;\r\n        }\r\n        else\r\n        {\r\n           //\r\n      \t\t//Beziehung auf der Gegenseite (am ${supplierClassName}) zu dieser Relationenklasse (${primary_type_name})\r\n\t      \t//mit Hilfe der remove...OneWay-Methode entfernen\r\n  \t    \t//\r\n          get${SupplierRoleName}().removeRelation${ClientRoleName}OneWay(this);\r\n        }\r\n      }\r\n      //\r\n      //Beziehung auf der Gegenseite (am ${supplierClassName}) zu dieser Relationenklasse (${primary_type_name})\r\n\t    //mit Hilfe der add...OneWay-Methode hinzufügen\r\n  \t  //\r\n      obj.addRelation${ClientRoleName}OneWay(this);\r\n    }\r\n    this.${supplierRoleName}.setValue(obj);\r\n  }\r\n  /**\r\n   * TOPLink ONE_TO_MANY: Wenn Attribut auf der Gegenseite navigierbar ist.\r\n   *\r\n   * @param obj ${supplierClassName}-Objekt für das eine Relation\r\n   *            hergestellt werden soll\r\n   */\r\n  public void set${SupplierRoleName}OneWay(final ${supplierClassName} obj)\r\n  {\r\n    // Falls es schon eine Referezen gibt, muß diese erst entfernt werden.\r\n    if (get${SupplierRoleName}() !\u003d null)\r\n    {\r\n      //\r\n      //Beziehung auf der Gegenseite (am ${supplierClassName}) zu dieser Relationenklasse (${primary_type_name})\r\n\t    //mit Hilfe der remove...OneWay-Methode entfernen\r\n  \t  //\r\n      get${SupplierRoleName}().removeRelation${ClientRoleName}OneWay(this);\r\n    }\r\n\r\n    this.${supplierRoleName}.setValue(obj);\r\n  }\r\n  /**\r\n   * Gibt den ValueHolder, bei einer 1:n Relation, für TOPLink zurück.\r\n   *\r\n   * @return ValueHolder für das lazy-loading von TOPLink\r\n   */\r\n  public ValueHolderInterface get${SupplierRoleName}Holder()\r\n  {\r\n    ValueHolderInterface holder \u003d this.${supplierRoleName};\r\n\r\n    if (holder.isInstantiated())\r\n    {\r\n      BoInterface bo \u003d (BoInterface) holder.getValue();\r\n      if (bo !\u003d null \u0026\u0026 !bo.getBoId().isValid())\r\n      {\r\n        holder.setValue(null);\r\n      }\r\n    }\r\n    return holder;\r\n  }\r\n  /**\r\n   * Setzt den ValueHolder, bei einer \"1-zu\" Relation, für TOPLink.\r\n   *\r\n   * @param valueHolder ValueHolder für das lazy-loading von TOPLink\r\n   */\r\n  public void set${SupplierRoleName}Holder(final ValueHolderInterface valueHolder)\r\n  {\r\n    this.${supplierRoleName} \u003d valueHolder;\r\n  }\r\n\r\n  /**\r\n   * Eindeutige BoId des Business Objects.\r\n   */\r\n  private transient BoId boId;\r\n  \r\n  /**\r\n   * Server-Nummer der BoId des Business Objects.\r\n   */\r\n  @Indexing(IndexingType.INDEX)\r\n  private long serverNr;\r\n  \r\n  /**\r\n   * Object-Nummer der BoId des Business Objects.\r\n   */\r\n  @Indexing(IndexingType.INDEX)\r\n  private long objectNr;\r\n  \r\n  /**\r\n   * TOPLink interne Version des Business Objects.\r\n   */\r\n  @Indexing(IndexingType.NO_INDEX)\r\n  private long version;\r\n  \r\n  /**\r\n   * TaskServerController der die UnitOfWork hält.\r\n   */\r\n  private transient TaskServerControllerInterface taskServerControllerInterface;\r\n  \r\n  /**\r\n   * TOPLink ValueHolder für lazy-loading zum abbilden der \"1-zu\"\r\n   */\r\n  @Indexing(IndexingType.INDEX)\r\n  private ValueHolderInterface ${clientRoleName} \u003d new ValueHolder();\r\n  \r\n  /**\r\n   * TOPLink ValueHolder für lazy-loading zum abbilden der \"1-zu\"\r\n   */\r\n  @Indexing(IndexingType.INDEX)\r\n  private ValueHolderInterface ${supplierRoleName} \u003d new ValueHolder();\r\n  \r\n  /**\r\n   * Dieses Kennzeichen gibt Auskunft, ob die Relation bereits logisch gelöscht ist, d.h. bei\u003cBR\u003e\r\n   * Auswertungen des RelationenControllers ggf. bereits nicht mehr berücksichtigt wird, und\u003cBR\u003e\r\n   * beim nächsten Aufruf von \"macheBestandswirksam\" durch setzen des Zeitpunktes\u003cBR\u003e\r\n   * \"gültigBis\" terminiert wird.\u003cBR\u003e\r\n   * Bei Aufruf der Methode \"löscheBeantragung\" wird das Kennzeichen wieder entfernt,\u003cBR\u003e\r\n   * da die Ursache für die logische Löschung nur beantragt war und gelöscht wird.\u003cBR\u003e\r\n   * \u003cBR\u003e\r\n   */\r\n  @Indexing(IndexingType.NO_INDEX)\r\n  private  boolean istLogischGeloescht \u003d false;\r\n  \r\n  /**\r\n   * Zeitpunkt, ab dem die Relation gültig ist.\u003cBR\u003e\r\n   * \u003cBR\u003e\r\n   */\r\n  private transient BotTimestamp gueltigAb \u003d null;\r\n  \r\n  /**\r\n   * Zeitpunkt, bis zu dem die Relation gültig ist. Bei Relationen, die unbegrenzt gültig\u003cBR\u003e\r\n   * sind ist der Zeitpunkt \"NULL\".\u003cBR\u003e\r\n   * \u003cBR\u003e\r\n   */\r\n  private transient BotTimestamp gueltigBis \u003d null;\r\n\r\n  /**\r\n   * Setzt den TaskServerController.\r\n   *\r\n   * @param tsc TaskServerController der die UnitOfWork hält.\r\n   */\r\n  public void setTaskServerControllerInterface(final TaskServerControllerInterface tsc)\r\n  {\r\n    this.taskServerControllerInterface \u003d tsc;\r\n  }\r\n\r\n  /**\r\n   * Gibt das TaskServerControllerInterface zurück.\r\n   *\r\n   * @return TaskServerController\r\n   */\r\n  public TaskServerControllerInterface getTaskServerControllerInterface()\r\n  {\r\n    return this.taskServerControllerInterface;\r\n  }\r\n  \r\n  /**\r\n   * Löscht das Business Object aus der Datenbank.\r\n   */\r\n  public void delete()\r\n  {\r\n    getTaskServerControllerInterface().deleteBo(this);\r\n  }\r\n\r\n  /**\r\n   * Liefert die eindeutige BoId des Business Objects.\r\n   *\r\n   * @return eindeutige BoId des Business Objects\r\n   */\r\n  public BoId getBoId()\r\n  {\r\n    if (this.boId \u003d\u003d null)\r\n    {\r\n      this.boId \u003d new BoId(this.serverNr, this.objectNr, this.getRoleName());\r\n    }\r\n    return this.boId;\r\n  }\r\n  \r\n  /**\r\n   * Mit Hilfe dieser Methode setzt der Konstruktor die BoId.\r\n   *\r\n   * @param newBoId BoId für das Objekt\r\n   */\r\n  protected final void setBoId(final BoId newBoId)\r\n  {\r\n    if (!newBoId.getRoleName().equals(this.getRoleName()))\r\n    {\r\n      throw new BoException(\r\n      \t\"Rolename mismatch: \" +\r\n      \tthis.getRoleName() + \" !\u003d \" +\r\n      \tnewBoId.getRoleName());\r\n    }\r\n    this.serverNr \u003d newBoId.getServerNr();\r\n    this.objectNr \u003d newBoId.getObjectNr();\r\n    this.boId \u003d newBoId;\r\n  }\r\n  \r\n  /**\r\n   * Liefert die Server-Nummer des Business Objects.\r\n   *\r\n   * @return Server-Nummer als long\r\n   */\r\n  public long getServerNr()\r\n  {\r\n    return this.serverNr;\r\n  }\r\n  \r\n  /**\r\n   * Setzt die Server-Nummer des BusinessObjects.\r\n   * \u003cb\u003eDiese Methode wird von TopLink benötigt,\r\n   * sie darf nicht benutzt werden!\u003c/b\u003e\r\n   *\r\n   * @param svrNr Server-Nummer des BusinessObjects\r\n   */\r\n  public void setServerNr(final long svrNr)\r\n  {\r\n    this.serverNr \u003d svrNr;\r\n  }\r\n  \r\n  /**\r\n   * Liefert die Object-Nummer des Business Objects.\r\n   *\r\n   * @return Object-Nummer als long\r\n   */\r\n  public long getObjectNr()\r\n  {\r\n    return this.objectNr;\r\n  }\r\n  \r\n  /**\r\n   * Setzt die Object-Nummer des BusinessObjects.\r\n   * \u003cb\u003eDiese Methode wird von TopLink benötigt,\r\n   * sie darf nicht benutzt werden!\u003c/b\u003e\r\n   *\r\n   * @param objNr Object-Nummer des BusinessObjects\r\n   */\r\n  public void setObjectNr(final long objNr)\r\n  {\r\n    this.objectNr \u003d objNr;\r\n  }\r\n\r\n  /**\r\n   * Liefert die Versionsnummer des Business Objects.\r\n   *\r\n   * @return Versionsnummer als long\r\n   */\r\n  public long getVersion()\r\n  {\r\n    return this.version;\r\n  }\r\n  /**\r\n   * Setzt die Versionsnummer des BusinessObjects.\r\n   * \u003cb\u003eDiese Methode wird von TopLink benötigt,\r\n   * sie darf nicht benutzt werden!\u003c/b\u003e\r\n   *\r\n   * @param versionNr Versionsnummer des BusinessObjects\r\n   */\r\n  public void setVersion(final long versionNr)\r\n  {\r\n    this.version \u003d versionNr;\r\n  }\r\n\r\n  /**\r\n   * Standardkonstruktor der Klasse ${primary_type_name}.\r\n   */\r\n  public ${primary_type_name}()\r\n  {\r\n  \t//Stansardkonstruktor erzeugt nur das Objekt\r\n  }\r\n  \r\n  /**\r\n   * Konstruktor der Klasse ${primary_type_name}\r\n   * der das Business Objekt mit einer BoId initialisiert.\r\n   *\r\n   * @param aBoId BoId mit der die Klasse initialisiert wird\r\n   */\r\n  public ${primary_type_name}(final BoId aBoId)\r\n  {\r\n    setBoId(aBoId);\r\n  }\r\n\r\n  /**\r\n   * Liefert den RoleName der Klasse.\r\n   *\r\n   * @return RoleName der Klasse\r\n   */\r\n  public String getRoleName()\r\n  {\r\n    return getClass().getName();\r\n  }\r\n  \r\n  /**\r\n   * Initialisiert die Klasse.\r\n   */\r\n  public void init()\r\n  {\r\n    //hier können Default-Werte des Bos gesetzt werden\r\n  }\r\n\r\n  /**\r\n   * Liefert den Zeitpunkt zurück, ab dem die Relation gültig war.\u003cBR\u003e\r\n   * \u003cBR\u003e\r\n   *\r\n   * @return BotTimestamp\r\n   */\r\n  public BotTimestamp gibZeitpunktGueltigBis()\r\n  {\r\n    return getGueltigBis();\r\n  }\r\n  \r\n  /**\r\n   * Liefert den Zeitpunkt zurück, ab dem die Relation gültig war.\u003cBR\u003e\r\n   * \u003cBR\u003e\r\n   *\r\n   * @return BotTimestamp\r\n   */\r\n  public BotTimestamp gibZeitpunktGueltigAb()\r\n  {\r\n    return getGueltigAb();\r\n  }\r\n\r\n  /**\r\n   * Liefert einen String mit Inhalten, welche die Entität eindeutig machen und Auskunft \u003cBR\u003e\r\n   * über ihren Zustand geben (z.B. BoId, eindeutige Nummern, Kontext und Zeitpunkte).\u003cBR\u003e\r\n   * \u003cBR\u003e\r\n   *\r\n   * @return String\r\n   */\r\n  public String toString()\r\n  {\r\n    return MessageFormat.format(\r\n      \"BoId \u003d {0}, Gültigkeit \u003d {1} - {2}, logisch gelöscht \u003d {3}\",\r\n      new Object[] {\r\n        getBoId(),\r\n        getGueltigAb(),\r\n        getGueltigBis(),\r\n        String.valueOf(getIstLogischGeloescht())});\r\n  }\r\n\r\n  /**\r\n   * Setzt den Zeitpunkt \"gültigBis\". \u003cBR\u003e\r\n   *\r\n   * @param bis BotTimestamp\r\n   */\r\n  public void setzeZeitpunktGueltigBis(final BotTimestamp bis)\r\n  {\r\n    setGueltigBis(bis);\r\n  }\r\n\r\n  /**\r\n   * Setzt den Zeitpunkt \"gültigAb\". \u003cBR\u003e\r\n   * \u003cBR\u003e\r\n   *\r\n   * @param ab BotTimestamp\r\n   */\r\n  public void setzeZeitpunktGueltigAb(final BotTimestamp ab)\r\n  {\r\n    setGueltigAb(ab);\r\n  }\r\n\r\n  /**\r\n   * Mit dieser Methode kann an der Relation ein Kennzeichen gesetzt werden, daß die\u003cBR\u003e\r\n   * Relation logisch gelöscht ist und bei Auswertungen ggf. berücksichtigt werden darf.\u003cBR\u003e\r\n   * Das Kennzeichen wird vom RelationenController ausgewertet.\u003cBR\u003e\r\n   * \u003cBR\u003e\r\n   *\r\n   * @param istLogischGeloescht boolean\r\n   */\r\n  public void setzeIstLogischGeloescht(final boolean istLogischGeloescht)\r\n  {\r\n    setIstLogischGeloescht(istLogischGeloescht);\r\n  }\r\n\r\n  /**\r\n   * Löscht die Relation.\u003cBR\u003e\r\n   * \u003cBR\u003e\r\n   * Implementierung:\u003cBR\u003e\r\n   * Die beiden Relationen zu den Entitäten werden auf \"null\" gesetzt.\u003cBR\u003e\r\n   */\r\n  public void loescheRelation()\r\n  {\r\n    set${ClientRoleName}(null);\r\n    set${SupplierRoleName}(null);\r\n    ((BESSM_RelationenController) getTaskServerControllerInterface().getBesModel(BESSM_RelationenController.class))\r\n      .loescheRelation(this);\r\n  }\r\n\r\n  /**\r\n   * Diese Methode liefert die Multiplizität zur übergebenen Rolle. Auf eine Plausibilisierung\u003cBR\u003e\r\n   * des Rollennamens kann verzichtet werden, da die Methode nur vom RelationenController\u003cBR\u003e\r\n   * benutzt wird und dieser bereits prüft.\u003cBR\u003e\r\n   * \u003cBR\u003e\r\n   *\r\n   * @param aRollenname String\r\n   * @return String\r\n   */\r\n  public String gibMultiplizitaet(final String aRollenname)\r\n  {\r\n    String result \u003d null;\r\n    if (aRollenname.equals(\"${ClientRoleName}\"))\r\n    {\r\n      result \u003d \"${clientMultiplicity}\";\r\n    }\r\n    else if (aRollenname.equals(\"${SupplierRoleName}\"))\r\n    {\r\n      result \u003d \"${supplierMultiplicity}\";\r\n    }\r\n    else\r\n    {\r\n      throw new BesRelationRuntimeException(\r\n        BesRelationRuntimeException.ERR_MULTIPLIZITAET_FUER_ROLLE_NICHT_DEFINIERT,\r\n        new String[]{aRollenname, String.valueOf(getBoId())});\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Diese Methode überprüft, ob die Relation zur übergebenen Rolle gerichtet, d. h. nur ein-\u003cBR\u003e\r\n   * seitig navigierbar, ist. Auf eine Plausibilisierung des Rollennamens kann verzichtet \u003cBR\u003e\r\n   * werden, da die Methode nur vom RelationenController benutzt wird und dieser bereits \u003cBR\u003e\r\n   * prüft.\u003cBR\u003e\r\n   * \u003cBR\u003e\r\n   *\r\n   * @param aRollenname String\r\n   * @return boolean\r\n   */\r\n  public boolean istRelationGerichtet(final String aRollenname)\r\n  {\r\n    boolean result \u003d false;\r\n\r\n    if (aRollenname.equals(\"${ClientRoleName}\"))\r\n    {\r\n      result \u003d false;\r\n    }\r\n    else if (aRollenname.equals(\"${SupplierRoleName}\"))\r\n    {\r\n      result \u003d false;\r\n    }\r\n    else\r\n    {\r\n      throw new BesRelationRuntimeException(\r\n        BesRelationRuntimeException.ERR_NAVIGIERBARKEIT_FUER_ROLLE_NICHT_DEFINIERT,\r\n        new String[]{aRollenname, String.valueOf(getBoId())});\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Diese Methode liefert zurück, ob die Relation als logisch gelöscht gekennzeichnet wurde\u003cBR\u003e\r\n   * und ob sie bei Auswertungen ggf. herausgefiltert werden muß.\u003cBR\u003e\r\n   * Dieses Kennzeichen wird von RelationenController benötigt.\u003cBR\u003e\r\n   * \u003cBR\u003e\r\n   *\r\n   * @return boolean\r\n   */\r\n  public boolean istLogischGeloescht()\r\n  {\r\n    return getIstLogischGeloescht();\r\n  }\r\n\r\n  /**\r\n   * Liefert zurück, ob die Relation bereits bestandswirksam ist. Dabei wird eine evtl. bereits\u003cBR\u003e\r\n   * durchgeführte logische Löschung in keiner Weise berücksichtigt. Es zählt nur ob die\u003cBR\u003e\r\n   * Relation irgendwann einmal gültig war oder ist, d.h. auch für historische Relationen\u003cBR\u003e\r\n   * wird WAHR zurückgeliefert.\u003cBR\u003e\r\n   * \u003cBR\u003e\r\n   * Implementierung:\u003cBR\u003e\r\n   * Wenn der Zeitpunkt \"gültigAb\" gesetzt (!\u003dnull) ist wird WAHR zurückgeliefert. Ansonsten\u003cBR\u003e\r\n   * FALSCH.\u003cBR\u003e\r\n   *\r\n   * @return boolean\r\n   */\r\n  public boolean istBestandswirksam()\r\n  {\r\n    return (getGueltigAb() !\u003d null);\r\n  }\r\n\r\n}\r\n\r\n/*\r\n * $$Log$$\r\n */",
  "location": "FILE",
  "filenameRestrictions": [],
  "dependencies": []
}