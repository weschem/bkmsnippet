{
  "uuid": "91b7864b-8409-4b6f-b16d-a1b2d75500c3",
  "name": "Ereignisfaehig",
  "description": "erzeugt die notwendigen Attribute und Methoden um ein Business Object ereignisfähig zu machen",
  "extraSearchTerms": [
    "Ereignisfähig",
    "Ereignis"
  ],
  "tags": [
    "ged",
    "relation"
  ],
  "code": "${:import(de.bkm.bes.basis.ereignis.BoIEreignis, de.bkm.bes.basis.ereignis.BoIEreignisfaehig, java.util.List, java.util.Vector, \r\n\tde.jdpe.bof.bo.eh.BoException, java.util.Comparator, java.util.Collections,\r\n\tde.jdpe.bof.bo.tm.BotTimestamp, de.bkm.bes.basis.history.entity.BoIKontextfaehig, de.jdpe.bof.bo.tm.BotContext)}\r\n\r\n/**\r\n * TOPLink-Attribut für die n: Relation zu Ereignissen\r\n * vom Typ ${ereignisklasse:var(java.lang.String)}\r\n */\r\n@Indexing(IndexingType.INDEX)\r\nprivate List\u003c${ereignisklasse}\u003e ereignisse \u003d new Vector\u003c${ereignisklasse}\u003e();\r\n\r\n/**\r\n   * Fügt eine Referenz auf ${ereignisklasse} hinzu.\r\n   * @param aEreignis Referenz auf ${ereignisklasse} die als Relation \r\n   * hinzugefügt wird.\r\n   */\r\n  public void addEreignisse(final ${ereignisklasse} aEreignis)\r\n  {\r\n    if (aEreignis \u003d\u003d null)\r\n    {\r\n      throw new BoException(\"Null can\u0027t be added as a relationship reference \"\r\n        + \"for ${primary_type_name}.ereignisse.\");\r\n    }\r\n\r\n    this.ereignisse.add(aEreignis);\r\n\r\n    // TOPLink MANY_TO_ONE: Wenn Attribut auf der Gegenseite navigierbar ist\r\n    aEreignis.setEreignisfaehigeEntitaetOneWay(this);\r\n  }\r\n\r\n  /**\r\n   * TOPLink MANY_TO_ANYTHING: Wenn Attribut auf der Gegenseite navigierbar ist\r\n   * @param aEreignis\r\n   */\r\n  public void addEreignisseOneWay(final ${ereignisklasse} aEreignis) \r\n  {\r\n    this.ereignisse.add(aEreignis);\r\n  }\r\n  \r\n  /**\r\n   * Entfernt die Relation zu dem übergebenen Objekt.\r\n   * @param aEreignis ${ereignisklasse} das aus der Relation entfernt werden soll.\r\n   */\r\n  public void removeEreignisse(final ${ereignisklasse} aEreignis)\r\n  {\r\n    if (aEreignis \u003d\u003d null)\r\n    {\r\n      throw new BoException(\"Null is not a reference which can be removed from\"\r\n        + \" relationship  ${primary_type_name}.ereignisse.\");\r\n    }\r\n\r\n    this.ereignisse.remove(aEreignis);\r\n\r\n    // TOPLink MANY_TO_ONE: Wenn Attribut auf der Gegenseite navigierbar ist\r\n    aEreignis.setEreignisfaehigeEntitaetOneWay(null);\r\n  }\r\n\r\n  /**\r\n   * TOPLink MANY_TO_ANYTHING: Wenn Attribut auf der Gegenseite navigierbar ist\r\n   * @param aEreignis\r\n   */\r\n  public void removeEreignisseOneWay(${ereignisklasse} aEreignis) \r\n  {\r\n    this.ereignisse.remove(aEreignis);\r\n  }\r\n\r\n/**\r\n   * Lieferte für TOPLink eine \u003ccode\u003eList\u003c/code\u003e der einer \"n zu\"-Relation.\r\n   * @return List für TOPLink lazy-loading\r\n   */\r\n  public List\u003c${ereignisklasse}\u003e getEreignisse()\r\n  {\r\n    return this.ereignisse;\r\n  }\r\n\r\n  /**\r\n   * Gibt einen Iterator mit Objekten, zu denen eine Relation besteht, zurück.\r\n   * @return Iterator mit ${ereignisklasse}\r\n   */\r\n  public NIterator\u003c${ereignisklasse}\u003e getEreignisseIterator()\r\n  {\r\n    NIterator\u003c${ereignisklasse}\u003e iterator \u003d\r\n      new NIterator\u003c${ereignisklasse}\u003e(this.ereignisse);\r\n\r\n    iterator.setTaskServerControllerInterface(getTaskServerControllerInterface());\r\n\r\n    return iterator;\r\n  }\r\n  \r\n  /**\r\n   * Gibt ein geklontes Set mit Objekten, zu denen die Relation ereignisse besteht, zurück.\r\n   *\r\n   * @return Set mit ${ereignisklasse}\r\n   */\r\n  public NSet\u003c${ereignisklasse}\u003e getEreignisseSet()\r\n  {\r\n    NSet\u003c${ereignisklasse}\u003e nSet \u003d\r\n      new NSet\u003c${ereignisklasse}\u003e();\r\n\t  NIterator\u003c${ereignisklasse}\u003e iter \u003d \r\n\t  \tgetEreignisseIterator();\r\n\r\n\t\twhile(iter.hasNext())\r\n\t\t{\r\n\t\t\tnSet.addTo(iter.next());\r\n\t\t}\r\n    \r\n    return nSet;\r\n  }\r\n\r\n/**\r\n   * Dient TOPLink dazu die \u003ccode\u003eList\u003c/code\u003e für lazy-loading der\r\n   * \"n zu\"-Relation zu setzen.\r\n   * @param aEreignisliste List für TOPLink lazy-loading\r\n   */\r\n  public void setEreignisse(final List\u003c${ereignisklasse}\u003e aEreignisliste)\r\n  {\r\n    this.ereignisse \u003d aEreignisliste;\r\n  }\r\n  \r\n/**\r\n  * Legt ein durch die Klasse spezifiziertes Ereignis an, ohne dieses jedoch \r\n  * mit der ereignisfähigen Entität zu assoziieren.\r\n  * @param \u003cT\u003e \r\n  * @param aEreignisklasse Klasse des zu erstellenden Ereignisses.\r\n  * @return Neu erstellte Instanz des Ereignisses.\r\n  */\r\n  protected \u003cT extends ${ereignisklasse}\u003e T legeEreignisAn(final Class\u003cT\u003e aEreignisklasse) \r\n  {\r\n    return getTaskServerControllerInterface().getNewBo(aEreignisklasse);\r\n  }\r\n  \r\n/**\r\n   * Fügt der ereignisfähigen Entität das übergebene Ereignis hinzu.\r\n   * @param aEreignis Ereignis, das der mit der ereignisfähigen Entität \r\n   * assoziiert werden soll.\r\n   */\r\n  protected void fuegeEreignisHinzu(final BoIEreignis aEreignis) \r\n  {\r\n    addEreignisse((${ereignisklasse}) aEreignis);\r\n  }\r\n\r\n/**\r\n   * Macht alle Ereignisse bestandswirksam.\r\n   * @param aZeitpunkt Zeitpunkt, mit und zu dem die Bestandswirksamkeit \r\n   * hergestellt wird.\r\n   */\r\n  private void macheBestandswirksamEreignisse(final BotTimestamp aZeitpunkt) \r\n  {\r\n    /*\r\n     * Die Ermittlung der Ereignisse muss auf jeden Fall über die get-Methode\r\n     * erfolgen, da die Methode gibEreignisse() das Methodenergebnis evtl.\r\n     * bereits filtert. (whe 12.01.2006)\r\n     */\r\n\r\n    NIterator\u003c${ereignisklasse}\u003e itrEreignisse \u003d  getEreignisseIterator();\r\n\r\n    while (itrEreignisse.hasNext())\r\n    {\r\n      itrEreignisse.nex().macheBestandswirksam(aZeitpunkt);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Löscht alle noch nicht bestandswirksamen Ereignisse.\r\n   */\r\n  private void loescheBeantragungEreignisse() \r\n  {\r\n    /*\r\n     * Die Ermittlung der Ereignisse muss auf jeden Fall über die get-Methode\r\n     * erfolgen, da die Methode gibEreignisse() das Methodenergebnis evtl.\r\n     * bereits filtert. \r\n     */\r\n\r\n    NSet\u003c${ereignisklasse}\u003e ereignisse \u003d new NSet\u003c${ereignisklasse}\u003e();\r\n    NIterator\u003c${ereignisklasse}\u003e itrEreignisse \u003d getEreignisseIterator();\r\n\r\n    while (itrEreignisse.hasNext())\r\n    {\r\n      ereignisse.addTo(itrEreignisse.next());\r\n    }\r\n\r\n    itrEreignisse \u003d ereignisse.iteratorFor();\r\n    while (itrEreignisse.hasNext())\r\n    {\r\n      BoIEreignis ereignis \u003d itrEreignisse.next();\r\n\r\n      if (!ereignis.istBestandswirksam())\r\n      {\r\n        loescheEreignis(ereignis);\r\n      }\r\n    }\r\n  }\r\n  \r\n /**\r\n   * Löscht alle der ereignisfähigen Entität zugeordneten Ereignisse.\r\n   */\r\n  private void loescheEreignisse() \r\n  {\r\n    NSet\u003c${ereignisklasse}\u003e ereignisse;\r\n    NIterator\u003c${ereignisklasse}\u003e itrEreignisse;\r\n    \r\n    ereignisse \u003d new NSet\u003c${ereignisklasse}\u003e(); \r\n    itrEreignisse \u003d getEreignisseIterator();\r\n\r\n    while (itrEreignisse.hasNext())\r\n    {\r\n      ereignisse.addTo(itrEreignisse.next());\r\n    }\r\n\r\n    itrEreignisse \u003d ereignisse.iteratorFor();\r\n    while (itrEreignisse.hasNext())\r\n    {\r\n      loescheEreignis(itrEreignisse.next());\r\n    }\r\n  }\r\n  \r\n /**\r\n   * Dereferenziert und löscht das übergebene Ereignis.\r\n   * @param aEreignis Zu löschendes Ereignis.\r\n   */\r\n  protected void loescheEreignis(final BoIEreignis aEreignis) \r\n  {\r\n    removeEreignisse((${ereignisklasse}) aEreignis);\r\n    aEreignis.loescheEntitaet();\r\n    aEreignis.delete();\r\n  }",
  "location": "JAVA",
  "filenameRestrictions": [],
  "dependencies": []
}