{
  "uuid": "91b7864b-8409-4b6f-b16d-a1b2d75500c3",
  "name": "Ereignisfaehig",
  "description": "",
  "extraSearchTerms": [
    "Ereignisfähig",
    "Ereignis"
  ],
  "tags": [
    "ged",
    "relation"
  ],
  "code": "${:import(de.bkm.bes.basis.ereignis.BoIEreignis, de.bkm.bes.basis.ereignis.BoIEreignisfaehig, java.util.List, java.util.Vector, \r\n\tde.jdpe.bof.bo.eh.BoException, java.util.Comparator, java.util.Collections,\r\n\tde.jdpe.bof.bo.tm.BotTimestamp, de.bkm.bes.basis.history.entity.BoIKontextfaehig, de.jdpe.bof.bo.tm.BotContext)}\r\n\r\n/**\r\n * TOPLink-Attribut für die n: Relation zu Ereignissen\r\n * vom Typ ${ereignisklasse:var(java.lang.String)}\r\n */\r\n@Indexing(IndexingType.INDEX)\r\nprivate List\u003c${ereignisklasse}\u003e ereignisse \u003d new Vector\u003c${ereignisklasse}\u003e();\r\n\r\n\r\n/**\r\n   * Fügt eine Referenz auf ${ereignisklasse} hinzu.\r\n   * @param aEreignis Referenz auf ${ereignisklasse} die als Relation \r\n   * hinzugefügt wird.\r\n   */\r\n  public void addEreignisse(final ${ereignisklasse} aEreignis)\r\n  {\r\n    if (aEreignis \u003d\u003d null)\r\n    {\r\n      throw new BoException(\"Null can\u0027t be added as a relationship reference \"\r\n        + \"for ${primary_type_name}.ereignisse.\");\r\n    }\r\n\r\n    this.ereignisse.add(aEreignis);\r\n\r\n    // TOPLink MANY_TO_ONE: Wenn Attribut auf der Gegenseite navigierbar ist\r\n    aEreignis.setEreignisfaehigeEntitaetOneWay(this);\r\n  }\r\n\r\n  /**\r\n   * TOPLink MANY_TO_ANYTHING: Wenn Attribut auf der Gegenseite navigierbar ist\r\n   * @param aEreignis\r\n   */\r\n  public void addEreignisseOneWay(final ${ereignisklasse} aEreignis) \r\n  {\r\n    this.ereignisse.add(aEreignis);\r\n  }\r\n  \r\n  /**\r\n   * Entfernt die Relation zu dem übergebenen Objekt.\r\n   * @param aEreignis ${ereignisklasse} das aus der Relation entfernt werden soll.\r\n   */\r\n  public void removeEreignisse(final ${ereignisklasse} aEreignis)\r\n  {\r\n    if (aEreignis \u003d\u003d null)\r\n    {\r\n      throw new BoException(\"Null is not a reference which can be removed from\"\r\n        + \" relationship  ${primary_type_name}.ereignisse.\");\r\n    }\r\n\r\n    this.ereignisse.remove(aEreignis);\r\n\r\n    // TOPLink MANY_TO_ONE: Wenn Attribut auf der Gegenseite navigierbar ist\r\n    aEreignis.setEreignisfaehigeEntitaetOneWay(null);\r\n  }\r\n\r\n  /**\r\n   * TOPLink MANY_TO_ANYTHING: Wenn Attribut auf der Gegenseite navigierbar ist\r\n   * @param aEreignis\r\n   */\r\n  public void removeEreignisseOneWay(${ereignisklasse} aEreignis) \r\n  {\r\n    this.ereignisse.remove(aEreignis);\r\n  }\r\n\r\n/**\r\n   * Lieferte für TOPLink eine \u003ccode\u003eList\u003c/code\u003e der einer \"n zu\"-Relation.\r\n   * @return List für TOPLink lazy-loading\r\n   */\r\n  public List\u003c${ereignisklasse}\u003e getEreignisse()\r\n  {\r\n    return this.ereignisse;\r\n  }\r\n\r\n  /**\r\n   * Gibt einen Iterator mit Objekten, zu denen eine Relation besteht, zurück.\r\n   * @return Iterator mit ${ereignisklasse}\r\n   */\r\n  public NIterator\u003c${ereignisklasse}\u003e getEreignisseIterator()\r\n  {\r\n    NIterator\u003c${ereignisklasse}\u003e iterator \u003d\r\n      new NIterator\u003c${ereignisklasse}\u003e(this.ereignisse);\r\n\r\n    iterator.setTaskServerControllerInterface(getTaskServerControllerInterface());\r\n\r\n    return iterator;\r\n  }\r\n  \r\n  /**\r\n   * Gibt ein geklontes Set mit Objekten, zu denen die Relation ereignisse besteht, zurück.\r\n   *\r\n   * @return Set mit ${ereignisklasse}\r\n   */\r\n  public NSet\u003c${ereignisklasse}\u003e getEreignisseSet()\r\n  {\r\n    NSet\u003c${ereignisklasse}\u003e nSet \u003d\r\n      new NSet\u003c${ereignisklasse}\u003e();\r\n\t  NIterator\u003c${ereignisklasse}\u003e iter \u003d \r\n\t  \tgetEreignisseIterator();\r\n\r\n\t\twhile(iter.hasNext())\r\n\t\t{\r\n\t\t\tnSet.addTo(iter.next());\r\n\t\t}\r\n    \r\n    return nSet;\r\n  }\r\n\r\n/**\r\n   * Dient TOPLink dazu die \u003ccode\u003eList\u003c/code\u003e für lazy-loading der\r\n   * \"n zu\"-Relation zu setzen.\r\n   * @param aEreignisliste List für TOPLink lazy-loading\r\n   */\r\n  public void setEreignisse(final List\u003c${ereignisklasse}\u003e aEreignisliste)\r\n  {\r\n    this.ereignisse \u003d aEreignisliste;\r\n  }\r\n  \r\n/**\r\n  * Legt ein durch die Klasse spezifiziertes Ereignis an, ohne dieses jedoch \r\n  * mit der ereignisfähigen Entität zu assoziieren.\r\n  * @param \u003cT\u003e \r\n  * @param aEreignisklasse Klasse des zu erstellenden Ereignisses.\r\n  * @return Neu erstellte Instanz des Ereignisses.\r\n  */\r\n  protected \u003cT extends ${ereignisklasse}\u003e T legeEreignisAn(final Class\u003cT\u003e aEreignisklasse) \r\n  {\r\n    return getTaskServerControllerInterface().getNewBo(aEreignisklasse);\r\n  }\r\n  \r\n/**\r\n   * Fügt der ereignisfähigen Entität das übergebene Ereignis hinzu.\r\n   * @param aEreignis Ereignis, das der mit der ereignisfähigen Entität \r\n   * assoziiert werden soll.\r\n   */\r\n  protected void fuegeEreignisHinzu(final BoIEreignis aEreignis) \r\n  {\r\n    addEreignisse((${ereignisklasse}) aEreignis);\r\n  }\r\n\r\n/**\r\n   * Macht alle Ereignisse bestandswirksam.\r\n   * @param aZeitpunkt Zeitpunkt, mit und zu dem die Bestandswirksamkeit \r\n   * hergestellt wird.\r\n   */\r\n  private void macheBestandswirksamEreignisse(final BotTimestamp aZeitpunkt) \r\n  {\r\n    /*\r\n     * Die Ermittlung der Ereignisse muss auf jeden Fall über die get-Methode\r\n     * erfolgen, da die Methode gibEreignisse() das Methodenergebnis evtl.\r\n     * bereits filtert. (whe 12.01.2006)\r\n     */\r\n\r\n    NIterator\u003c${ereignisklasse}\u003e itrEreignisse \u003d  getEreignisseIterator();\r\n\r\n    while (itrEreignisse.hasNext())\r\n    {\r\n      itrEreignisse.nex().macheBestandswirksam(aZeitpunkt);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Löscht alle noch nicht bestandswirksamen Ereignisse.\r\n   */\r\n  private void loescheBeantragungEreignisse() \r\n  {\r\n    /*\r\n     * Die Ermittlung der Ereignisse muss auf jeden Fall über die get-Methode\r\n     * erfolgen, da die Methode gibEreignisse() das Methodenergebnis evtl.\r\n     * bereits filtert. \r\n     */\r\n\r\n    NSet\u003c${ereignisklasse}\u003e ereignisse \u003d new NSet\u003c${ereignisklasse}\u003e();\r\n    NIterator\u003c${ereignisklasse}\u003e itrEreignisse \u003d getEreignisseIterator();\r\n\r\n    while (itrEreignisse.hasNext())\r\n    {\r\n      ereignisse.addTo(itrEreignisse.next());\r\n    }\r\n\r\n    itrEreignisse \u003d ereignisse.iteratorFor();\r\n    while (itrEreignisse.hasNext())\r\n    {\r\n      BoIEreignis ereignis \u003d itrEreignisse.next();\r\n\r\n      if (!ereignis.istBestandswirksam())\r\n      {\r\n        loescheEreignis(ereignis);\r\n      }\r\n    }\r\n  }\r\n  \r\n /**\r\n   * Löscht alle der ereignisfähigen Entität zugeordneten Ereignisse.\r\n   */\r\n  private void loescheEreignisse() \r\n  {\r\n    NSet\u003c${ereignisklasse}\u003e ereignisse;\r\n    NIterator\u003c${ereignisklasse}\u003e itrEreignisse;\r\n    \r\n    ereignisse \u003d new NSet\u003c${ereignisklasse}\u003e(); \r\n    itrEreignisse \u003d getEreignisseIterator();\r\n\r\n    while (itrEreignisse.hasNext())\r\n    {\r\n      ereignisse.addTo(itrEreignisse.next());\r\n    }\r\n\r\n    itrEreignisse \u003d ereignisse.iteratorFor();\r\n    while (itrEreignisse.hasNext())\r\n    {\r\n      loescheEreignis(itrEreignisse.next());\r\n    }\r\n  }\r\n  \r\n /**\r\n   * Dereferenziert und löscht das übergebene Ereignis.\r\n   * @param aEreignis Zu löschendes Ereignis.\r\n   */\r\n  protected void loescheEreignis(final BoIEreignis aEreignis) \r\n  {\r\n    removeEreignisse((${ereignisklasse}) aEreignis);\r\n    aEreignis.loescheEntitaet();\r\n    aEreignis.delete();\r\n  }\r\n  \r\n /**\r\n  * @see de.bkm.bes.basis.ereignis.BoIEreignisfaehig#gibEreignisse()\r\n  * @return Alle Ereignisse der ereignisfähigen Entität. Das Methodenergebnis\r\n  * ist chronologisch absteigend sortiert (jüngstes Ereignis als erstes).\u003cbr\u003e\r\n  * Sollte die Entität kontextfähig sein, so wird bei der Ermittlung der \r\n  * Ereignisse auch der aktuell gesetzte Kontext berücksichtigt.\u003cbr\u003e\r\n  */\r\n  @Override\r\n  public NIterator\u003cBoIEreignis\u003e gibEreignisse() \r\n  {\r\n    NSet\u003cBoIEreignis\u003e ereignisse \u003d new NSet\u003cBoIEreignis\u003e();\r\n    NIterator\u003c${ereignisklasse}\u003e itrEreignisse;\r\n    \r\n    //\r\n    // alle relevanten Vertragsereignisse ermitteln\r\n    //\r\n    itrEreignisse \u003d getEreignisseIterator();\r\n    \r\n    if (!BoIKontextfaehig.class.isAssignableFrom(getClass()))\r\n    {\r\n      while (itrEreignisse.hasNext())\r\n      {\r\n        ereignisse.addTo(itrEreignisse.next());\r\n      }\r\n    }\r\n    else\r\n    {\r\n      final BotContext kontext \u003d ((BoIKontextfaehig) this).gibKontext();\r\n      final BotContext neuester \u003d BotContext.NEUESTER_ZUSTAND;\r\n      final BotContext aktueller \u003d BotContext.AKTUELL_BESTANDSWIRKSAMER_ZUSTAND;\r\n      \r\n      while (itrEreignisse.hasNext())\r\n      {\r\n        BoIEreignis ereignis \u003d itrEreignisse.next();\r\n        BotTimestamp bz \u003d ereignis.gibBestandswirksamkeitszeitpunkt();\r\n        BotTimestamp hz \u003d kontext.getHistoricalTimestamp();\r\n        \r\n        if (kontext \u003d\u003d neuester\r\n          || (kontext \u003d\u003d aktueller \u0026\u0026 ereignis.istBestandswirksam())\r\n          || (kontext.isHistoricalContext() \u0026\u0026 bz !\u003d null \u0026\u0026 !bz.isAfter(hz)))\r\n        {\r\n          ereignisse.addTo(ereignis);\r\n        }\r\n      }\r\n    }\r\n\r\n    /*\r\n     * ACHTUNG!\r\n     * Die gesamte Implementierung der ereignisfähigen Entität verlässt sich auf \r\n     * die nachfolgende Sortierung! Das jüngste Ereignis muss immer das erste \r\n     * Element der Ergebnisliste sein!\r\n     */\r\n    \r\n    //\r\n    // Ereignisse sortieren\r\n    //\r\n    Collections.sort(\r\n      ereignisse,\r\n      new Comparator\u003cBoIEreignis\u003e()\r\n      {\r\n        public int compare(BoIEreignis element1, BoIEreignis element2)\r\n        {\r\n          int result;\r\n          BotTimestamp zeitpunkt1;\r\n          BotTimestamp zeitpunkt2;\r\n          \r\n          //\r\n          // Sortierung nach Bestandswirksamkeitszeitpunkt\r\n          //\r\n          zeitpunkt1 \u003d \r\n             element1\r\n            .gibBestandswirksamkeitszeitpunkt();\r\n          zeitpunkt2 \u003d \r\n            element2\r\n            .gibBestandswirksamkeitszeitpunkt();\r\n          \r\n          if (zeitpunkt1 \u003d\u003d null \u0026\u0026 zeitpunkt2 \u003d\u003d null)\r\n          {\r\n            result \u003d 0;\r\n          }\r\n          else if (zeitpunkt2 \u003d\u003d null \r\n            || (zeitpunkt1 !\u003d null \u0026\u0026 zeitpunkt1.isBefore(zeitpunkt2)))\r\n          {\r\n            result \u003d 1;\r\n          }\r\n          else if (zeitpunkt1 \u003d\u003d null || zeitpunkt1.isAfter(zeitpunkt2))\r\n          {\r\n            result \u003d -1;\r\n          }\r\n          else\r\n          {\r\n            result \u003d 0;\r\n          }\r\n          \r\n          //\r\n          // Sortierung nach Erstellungszeitpunkt, sofern Bestandswirksamkeits-\r\n          // zeitpunkte identisch sind\r\n          //\r\n          if (result \u003d\u003d 0)\r\n          {\r\n            zeitpunkt1 \u003d \r\n               element1.gibErstellungszeitpunkt();\r\n            zeitpunkt2 \u003d \r\n              element2.gibErstellungszeitpunkt();\r\n            \r\n            if (zeitpunkt1 !\u003d null \u0026\u0026 zeitpunkt2 !\u003d null)\r\n            {\r\n              result \u003d zeitpunkt1.compareTo(zeitpunkt2) * -1;\r\n            }\r\n          }\r\n          \r\n          return result;\r\n        }\r\n      });\r\n    \r\n    return ereignisse.iteratorFor();\r\n  } \r\n\r\n  /**\r\n   * @see de.bkm.bes.basis.ereignis.BoIEreignisfaehig#gibEreignisse(java.lang.Class)\r\n   * @param aEreignisklasse Ereignissklasse, welche für die Filterung der\r\n   * Ereignisse verwendet wird.\r\n   * @return Alle Ereignisse, der angegebenen Klasse oder deren \r\n   * Spezialisierungen.\u003cbr\u003e \r\n   * Das Methodenergebnis ist chronologisch absteigend sortiert (jüngstes \r\n   * Ereignis als erstes).\u003cbr\u003e\r\n   * Sollte die Entität kontextfähig sein, so wird bei der Ermittlung der \r\n   * Ereignisse auch der aktuell gesetzte Kontext berücksichtigt.\r\n   */\r\n  @Override\r\n  @SuppressWarnings(\"unchecked\")\r\n  public \u003cT extends BoIEreignis\u003e NIterator\u003cT\u003e gibEreignisse(\r\n     final Class\u003cT\u003e aEreignisklasse) \r\n  {\r\n    NIterator\u003cBoIEreignis\u003e itrator \u003d gibEreignisse();\r\n    NSet\u003cT\u003e result \u003d new NSet\u003cBoIEreignis\u003e();\r\n    \r\n    while (itrator.hasNext())\r\n    {\r\n      BoIEreignis ereignis \u003d itrator.next();\r\n      \r\n      if (aEreignisklasse.isAssignableFrom(ereignis.getClass()))\r\n      {\r\n        result.addTo((T)ereignis);\r\n      }\r\n    }\r\n    \r\n    return result.iteratorFor();\r\n  }\r\n  \r\n  \r\n  \r\n/**\r\n  * @see de.bkm.bes.basis.ereignis.BoIEreignisfaehig#gibAeltestesEreignis(java.lang.Class)\r\n  * @param aEreignisklasse Ereignissklasse, welche für die Filterung der\r\n  * Ereignisse verwendet wird.\r\n  * @return Ältestes Ereignis, der angegebenen Klasse oder deren \r\n  * Spezialisierungen.\r\n  */\r\n  @Override\r\n  @SuppressWarnings(\"unchecked\")\r\n  public \u003cT extends BoIEreignis\u003e T gibAeltestesEreignis(final Class\u003cT\u003e aEreignisklasse) \r\n  {\r\n    T result \u003d null;\r\n    NIterator\u003cBoIEreignis\u003e itrEreignisse \u003d gibEreignisse();\r\n    \r\n    while (itrEreignisse.hasNext())\r\n    {\r\n      BoIEreignis ereignis \u003d itrEreignisse.next();\r\n      \r\n      if (aEreignisklasse.isAssignableFrom(ereignis.getClass()))\r\n      {\r\n        result \u003d (T) ereignis;\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n  \r\n/**\r\n  * @see de.bkm.bes.basis.ereignis.BoIEreignisfaehig#gibJuengstesEreignis(java.lang.Class)\r\n  * @param aEreignisklasse Ereignissklasse, welche für die Filterung der\r\n  * Ereignisse verwendet wird.\r\n  * @return Jüngstes Ereignis, der angegebenen Klasse oder deren \r\n  * Spezialisierungen.\r\n  */\r\n  @Override\r\n  @SuppressWarnings(\"unchecked\")\r\n  public \u003cT extends BoIEreignis\u003e T gibJuengstesEreignis(final Class\u003cT\u003e aEreignisklasse) \r\n  {\r\n    T result \u003d null;\r\n    NIterator\u003cBoIEreignis\u003e itrEreignisse \u003d gibEreignisse();\r\n    \r\n    while (itrEreignisse.hasNext())\r\n    {\r\n      BoIEreignis ereignis \u003d itrEreignisse.next();\r\n      \r\n      if (aEreignisklasse.isAssignableFrom(ereignis.getClass()))\r\n      {\r\n        result \u003d (T) ereignis;\r\n        break;\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }",
  "location": "JAVA",
  "filenameRestrictions": [],
  "dependencies": []
}